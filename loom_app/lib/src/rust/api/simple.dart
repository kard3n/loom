// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `into`, `into`, `into`

String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AppDatabase>>
abstract class AppDatabase implements RustOpaqueInterface {
  Future<void> createPost({required Post post});

  Future<void> createTotem({required Totem totem});

  Future<void> createUser({required User user});

  Future<List<Post>> getAllPosts();

  Future<List<Totem>> getAllTotems();

  Future<List<User>> getAllUsers();

  Future<Post> getPostById({required String uuid});

  Future<List<String>> getPostIdsInRange({
    required DateTime start,
    required DateTime end,
  });

  Future<User> getUserById({required String uuid});

  factory AppDatabase({required String path}) =>
      RustLib.instance.api.crateApiSimpleAppDatabaseNew(path: path);

  Future<void> updateTotemLastContact({
    required String uuid,
    required DateTime lastContact,
  });

  Future<void> updateUser({required User user});
}

class Post {
  final String uuid;
  final String userId;
  final String title;
  final String body;
  final DateTime timestamp;
  final String? image;
  final String sourceTotem;

  const Post({
    required this.uuid,
    required this.userId,
    required this.title,
    required this.body,
    required this.timestamp,
    this.image,
    required this.sourceTotem,
  });

  @override
  int get hashCode =>
      uuid.hashCode ^
      userId.hashCode ^
      title.hashCode ^
      body.hashCode ^
      timestamp.hashCode ^
      image.hashCode ^
      sourceTotem.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Post &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid &&
          userId == other.userId &&
          title == other.title &&
          body == other.body &&
          timestamp == other.timestamp &&
          image == other.image &&
          sourceTotem == other.sourceTotem;
}

class Totem {
  final String uuid;
  final String name;
  final String location;
  final DateTime lastContact;

  const Totem({
    required this.uuid,
    required this.name,
    required this.location,
    required this.lastContact,
  });

  @override
  int get hashCode =>
      uuid.hashCode ^ name.hashCode ^ location.hashCode ^ lastContact.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Totem &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid &&
          name == other.name &&
          location == other.location &&
          lastContact == other.lastContact;
}

class User {
  final String uuid;
  final String username;
  final String status;
  final String bio;
  final String? profilePicture;
  final DateTime lastContact;

  const User({
    required this.uuid,
    required this.username,
    required this.status,
    required this.bio,
    this.profilePicture,
    required this.lastContact,
  });

  @override
  int get hashCode =>
      uuid.hashCode ^
      username.hashCode ^
      status.hashCode ^
      bio.hashCode ^
      profilePicture.hashCode ^
      lastContact.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is User &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid &&
          username == other.username &&
          status == other.status &&
          bio == other.bio &&
          profilePicture == other.profilePicture &&
          lastContact == other.lastContact;
}
